
.. _program_listing_file_include_reactor-cpp_value_ptr.hh:

Program Listing for File value_ptr.hh
=====================================

|exhale_lsh| :ref:`Return to documentation for file <file_include_reactor-cpp_value_ptr.hh>` (``include/reactor-cpp/value_ptr.hh``)

.. |exhale_lsh| unicode:: U+021B0 .. UPWARDS ARROW WITH TIP LEFTWARDS

.. code-block:: cpp

   /*
    * Copyright (C) 2019 TU Dresden
    * All rights reserved.
    *
    * Authors:
    *   Christian Menard
    */
   
   #pragma once
   
   #include <memory>
   #include <type_traits>
   
   namespace reactor {
   
   // forward declaration
   template <class T>
   class ImmutableValuePtr;
   
   template <class T>
   class MutableValuePtr {
    private:
     std::unique_ptr<T> internal_ptr;
   
     explicit MutableValuePtr(T* value) : internal_ptr(value) {}
   
    public:
     constexpr MutableValuePtr() : internal_ptr(nullptr) {}
     MutableValuePtr(const MutableValuePtr&) = delete;
     MutableValuePtr(MutableValuePtr&& ptr) = default;
     explicit constexpr MutableValuePtr(std::nullptr_t) : internal_ptr(nullptr) {}
   
     MutableValuePtr& operator=(MutableValuePtr&& ptr) {
       this->internal_ptr = std::move(ptr.internal_ptr);
       return *this;
     }
     MutableValuePtr& operator=(std::nullptr_t) {
       this->internal_ptr = nullptr;
       return *this;
     }
   
     T* get() const { return internal_ptr.get(); }
   
     explicit operator bool() const { return get() == nullptr; }
   
     T& operator*() const { return *get(); }
     T* operator->() const { return get(); }
   
     // Give ImutableValuePtr access to the private constructor. This is required
     // for creating a MutableValuePtr from an ImutableValuePtr in
     // get_mutable_copy()
     friend class ImmutableValuePtr<T>;
   
     // Give the factory function make_mutable_value() access to the private
     // constructor
     template <class U, class... Args>
     friend MutableValuePtr<U> make_mutable_value(Args&&... args);
   };
   
   template <class T>
   class ImmutableValuePtr {
    public:
     using const_T = typename std::add_const<T>::type;
   
    private:
     std::shared_ptr<T> internal_ptr;
   
     explicit ImmutableValuePtr(T* value) : internal_ptr(value) {}
   
    public:
     constexpr ImmutableValuePtr() : internal_ptr(nullptr) {}
     ImmutableValuePtr(const ImmutableValuePtr& ptr) = default;
     ImmutableValuePtr(ImmutableValuePtr&& ptr) = default;
     explicit constexpr ImmutableValuePtr(std::nullptr_t)
         : internal_ptr(nullptr) {}
     explicit ImmutableValuePtr(MutableValuePtr<T>&& ptr)
         : internal_ptr(std::move(ptr.internal_ptr)) {}
   
     ImmutableValuePtr& operator=(std::nullptr_t) {
       this->internal_ptr = nullptr;
       return *this;
     }
     ImmutableValuePtr& operator=(const ImmutableValuePtr& ptr) {
       this->internal_ptr = ptr.internal_ptr;
       return *this;
     }
     ImmutableValuePtr& operator=(ImmutableValuePtr&& ptr) {
       this->internal_ptr = std::move(ptr.internal_ptr);
       return *this;
     }
   
     const_T* get() const { return internal_ptr.get(); }
   
     explicit operator bool() const { return get() == nullptr; }
   
     const_T& operator*() const { return *get(); }
     const_T* operator->() const { return get(); }
   
     MutableValuePtr<T> get_mutable_copy() const {
       return MutableValuePtr<T>(new T(*internal_ptr));
     }
   
     // Give the factory function make_mutable_value() access to the private
     // constructor
     template <class U, class... Args>
     friend ImmutableValuePtr<U> make_immutable_value(Args&&... args);
   };
   
   template <class T, class... Args>
   ImmutableValuePtr<T> make_immutable_value(Args&&... args) {
     return ImmutableValuePtr<T>(new T(std::forward<Args>(args)...));
   }
   
   template <class T, class... Args>
   MutableValuePtr<T> make_mutable_value(Args&&... args) {
     return MutableValuePtr<T>(new T(std::forward<Args>(args)...));
   }
   
   // Comparison operators
   
   template <class T, class U>
   bool operator==(const MutableValuePtr<T>& x, const MutableValuePtr<U>& y) {
     return x.get() == y.get();
   }
   template <class T, class U>
   bool operator==(const ImmutableValuePtr<T>& x, const ImmutableValuePtr<U>& y) {
     return x.get() == y.get();
   }
   template <class T, class U>
   bool operator==(const ImmutableValuePtr<T>& x, const MutableValuePtr<U>& y) {
     return x.get() == y.get();
   }
   template <class T, class U>
   bool operator==(const MutableValuePtr<T>& x, const ImmutableValuePtr<U>& y) {
     return x.get() == y.get();
   }
   template <class T>
   bool operator==(const MutableValuePtr<T>& x, std::nullptr_t) {
     return x.get() == nullptr;
   }
   template <class T>
   bool operator==(std::nullptr_t, const MutableValuePtr<T>& x) {
     return x.get() == nullptr;
   }
   template <class T>
   bool operator==(const ImmutableValuePtr<T>& x, std::nullptr_t) {
     return x.get() == nullptr;
   }
   template <class T>
   bool operator==(std::nullptr_t, const ImmutableValuePtr<T>& x) {
     return x.get() == nullptr;
   }
   
   template <class T, class U>
   bool operator!=(const MutableValuePtr<T>& x, const MutableValuePtr<U>& y) {
     return x.get() != y.get();
   }
   template <class T, class U>
   bool operator!=(const ImmutableValuePtr<T>& x, const ImmutableValuePtr<U>& y) {
     return x.get() != y.get();
   }
   template <class T, class U>
   bool operator!=(const ImmutableValuePtr<T>& x, const MutableValuePtr<U>& y) {
     return x.get() != y.get();
   }
   template <class T, class U>
   bool operator!=(const MutableValuePtr<T>& x, const ImmutableValuePtr<U>& y) {
     return x.get() != y.get();
   }
   template <class T>
   bool operator!=(const MutableValuePtr<T>& x, std::nullptr_t) {
     return x.get() != nullptr;
   }
   template <class T>
   bool operator!=(std::nullptr_t, const MutableValuePtr<T>& x) {
     return x.get() != nullptr;
   }
   template <class T>
   bool operator!=(const ImmutableValuePtr<T>& x, std::nullptr_t) {
     return x.get() != nullptr;
   }
   template <class T>
   bool operator!=(std::nullptr_t, const ImmutableValuePtr<T>& x) {
     return x.get() != nullptr;
   }
   
   }  // namespace reactor
