
.. _program_listing_file_lib_logical_time.cc:

Program Listing for File logical_time.cc
========================================

|exhale_lsh| :ref:`Return to documentation for file <file_lib_logical_time.cc>` (``lib/logical_time.cc``)

.. |exhale_lsh| unicode:: U+021B0 .. UPWARDS ARROW WITH TIP LEFTWARDS

.. code-block:: cpp

   /*
    * Copyright (C) 2019 TU Dresden
    * All rights reserved.
    *
    * Authors:
    *   Christian Menard
    */
   
   #include "reactor-cpp/logical_time.hh"
   
   #include "reactor-cpp/assert.hh"
   
   namespace reactor {
   
   bool operator==(const Tag& lhs, const Tag& rhs) {
     return lhs.time_point() == rhs.time_point() &&
            lhs.micro_step() == rhs.micro_step();
   }
   
   bool operator<(const Tag& lhs, const Tag& rhs) {
     return lhs.time_point() < rhs.time_point() ||
            (lhs.time_point() == rhs.time_point() &&
             lhs.micro_step() < rhs.micro_step());
   }
   
   Tag Tag::from_physical_time(TimePoint time_point) { return Tag{time_point, 0}; }
   
   Tag Tag::from_logical_time(const LogicalTime& lt) {
     return Tag{lt.time_point(), lt.micro_step()};
   }
   
   Tag Tag::delay(Duration offset) const {
     if (offset == Duration::zero()) {
       return Tag{this->_time_point, this->_micro_step + 1};
     } else {
       return Tag{this->_time_point + offset, 0};
     }
   }
   
   void LogicalTime::advance_to(const Tag& tag) {
     toggle_assert(*this < tag);
     _time_point = tag.time_point();
     _micro_step = tag.micro_step();
   }
   
   bool operator==(const LogicalTime& lhs, const Tag& rhs) {
     return lhs.time_point() == rhs.time_point() &&
            lhs.micro_step() == rhs.micro_step();
   }
   
   bool operator<(const LogicalTime& lhs, const Tag& rhs) {
     return lhs.time_point() < rhs.time_point() ||
            (lhs.time_point() == rhs.time_point() &&
             lhs.micro_step() < rhs.micro_step());
   }
   
   bool operator>(const LogicalTime& lhs, const Tag& rhs) {
     return lhs.time_point() > rhs.time_point() ||
            (lhs.time_point() == rhs.time_point() &&
             lhs.micro_step() > rhs.micro_step());
   }
   
   }  // namespace reactor
